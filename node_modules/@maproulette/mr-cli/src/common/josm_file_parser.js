const { DOMParser, XMLSerializer } = require('xmldom')
const xmlToJSON = require('xmlToJSON')
const _fromPairs = require('lodash.frompairs')
const _find = require('lodash.find')
const Utils = require('./utils')

// Setup xmlToJSON make use of the DOMParser package since there's no browser
xmlToJSON.stringToXML = (string) => new DOMParser().parseFromString(string, 'text/xml')

const JOSMFileParser = {
  /**
   * Parse JSON representation of JOSM change file, returning intermediate data
   * structures used for conversion
   */
  parse: function(josmData) {
    const json = Utils.normalizeAttributes(xmlToJSON.parseString(josmData.toString()))

    const elementMaps = {
      node: new Map(),
      way: new Map(),
      relation: new Map()
    }
    const changes = []
    const references = []

    const data = json.osm[0]
    const elementDataSets = ['node', 'way', 'relation'].map(
      elementType => ({elementType, map: elementMaps[elementType], elements: data[elementType]})
    )

    elementDataSets.forEach(elementSet => {
      if (elementSet.elements) {
        elementSet.elements.forEach(element => {
          elementSet.map.set(element.id, element)
          if (element.action) {
            changes.push([{
              elementType: elementSet.elementType,
              elementId: element.id,
              element,
              operation: element.action
            }])

            if (element.nd) {
              element.nd.forEach(nodeRef => {
                references.push({elementType: 'node', elementId: nodeRef.ref})
              })
            }
            else if (element.member) {
              element.member.forEach(member => {
                references.push({elementType: member.type, elementId: member.ref})
              })
            }
          }
        })
      }
    })

    // Build array of top-level elements that aren't referenced by other
    // elements
    const topLevelElements = []
    changes.forEach(changeElements => {
      changeElements.forEach(element => {
        const isReferenced = _find(references, ref =>
          ref.elementType === element.elementType && ref.elementId === element.elementId
        )

        if (!isReferenced) {
          topLevelElements.push(element)
        }
      })
    })

    return ({
      elementMaps,
      elementDataSetsByType: _fromPairs(elementDataSets.map(es => [es.elementType, es])),
      changes,
      references,
      topLevelElements,
    })
  },

  /**
   * Explode a single JOSM change XML document with multiple changes into
   * multiple XML documents, with one change per document (plus OSM elements
   * referenced by the change)
   */
  explode: function(xmlString) {
    // Note that "nodes" here refer to XML nodes, not OSM nodes
    const doc = new DOMParser().parseFromString(xmlString)
    const parentNode = doc.getElementsByTagName('osm').item(0)

    const supportingNodesById = new Map()
    const actionNodes = []
    for (let i = 0; i < parentNode.childNodes.length; i++) {
      const currentNode = parentNode.childNodes.item(i)

      // skip extraneous XML nodes, such as text nodes
      if (currentNode.nodeName !== 'node' &&
          currentNode.nodeName !== 'way' &&
          currentNode.nodeName !== 'relation') {
        continue
      }

      // XML nodes with an action attribute will become separate docs
      if (currentNode.attributes.getNamedItem('action')) {
        actionNodes.push(currentNode)
      }

      // XML node may be referenced later as a supporting entity
      supportingNodesById.set(
        `${currentNode.nodeName}/${currentNode.attributes.getNamedItem('id').nodeValue}`,
        currentNode
      )
    }

    // Generate separate, stand-alone XML documents for each change
    const serializer = new XMLSerializer()
    const separateChanges = []
    actionNodes.forEach(taskNode => {
      const change =
        "<?xml version='1.0' encoding='UTF-8'?>\n" +
        "<osm version='0.6' generator='JOSM'>\n" +
          Utils.serializeSupportingNodes(taskNode, supportingNodesById, serializer) +
          serializer.serializeToString(taskNode) + "\n" +
        "</osm>"

      separateChanges.push(change)
    })

    return separateChanges
  },
}

module.exports = JOSMFileParser
